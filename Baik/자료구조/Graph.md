# 그래프란?
그래프는 여러 개의 노드(node)와 이들을 연결하는 간선(Edge)으로 이루어진 자료구조이다.

- 노드(node)는 정점(Vertex)으로 표현될 수 있다.

## 그래프의 구성 요소와 용어

그래프는 정점과 간선으로 이루어져 있다.

- 정점(Vertex or Node)
: 데이터를 저장하는 위치
- 간선(Edge)
: 정점(노드)를 연결하는 선. 링크(Link) 또는 브랜치(branch) 로도 불린다.
- 인접 정점(adjacent vertex)
: 간선에 의해 직접 연결된 정점을 의미한다. 위의 그림에서 1과 2는 인접 정점이다.
- 단순 경로(simple path)
: 경로 중에서 반복되는 정점이 없는 경우를 의미한다. 한붓 그리기와 같이 같은 간선을 지나가지 않는 경로를 의미한다. 
- 차수(degree)
: 무방향 그래프에서 하나의 정점에 인접한 정점의 수를 의미한다. 1의 차수는 2이다.
- 진출 차수(in-degree)
: 방향 그래프에서 외부로 향하는 간선의 수를 의미한다.
- 진입 자수(out-degree)
: 방향 그래프에서 외부에서 들어오는 간선의 수를 의미한다.
- 경로 길이(path length)
: 경로를 구성하는데 사용된 간선의 수를 의미한다. 
- 사이클(cycle)
: 단순 경로의 시작 정점과 종료 정점이 동일한 경우를 의미한다.


## 그래프의 특징

그래프는 여러가지 특징을 가질 수 있다. 다만 하나의 그래프가 모든 특징을 가지는 것이 아니라 특징을 가짐에 따라 그래프의 종류도 나뉘어 진다.

#### 무방향성(Unidirectionality)
그래프의 간선은 방향성이 없을 수 있으며, 양쪽 방향으로 모두 이동할 수 있다.
이러한 그래프를 무방향 그래프(undirected graph)라고 부른다.

#### 방향성(Directionality)
그래프의 간선은 방향성이 있을 수 있으며, 한쪽 방향으로만 이동할 수 있다.
이러한 그래프를 방향 그래프(directed graph) 또는 유향 그래프(digraph)라고 부른다.

#### 가중치(Weight)
그래프의 간선에 가중치(weight)를 부여할 수 있다.
가중치를 부여한 그래프를 가중치 그래프(weighted graph)라고 부르며, 보통은 거리, 비용, 우선순위 등을 나타내는 데 사용된다.

#### 연결성(Connectivity)
그래프에서 노드와 노드 사이에 경로가 존재하면, 두 노드는 연결되었다고 말한다. 그래프가 연결되어 있는 경우 연결 그래프(connected graph)라고 부르며, 그렇지 않은 경우 비연결 그래프(disconnected graph)이다.

#### 사이클(Cycle)
그래프에서 한 노드에서 시작하여 경로를 따라가면서 마침내 자기 자신으로 돌아오는 경로를 사이클(cycle)이라고 부른다. 사이클이 없는 그래프를 비순환 그래프(acyclic graph)라고 부르며, 사이클이 있는 그래프를 순환 그래프(cyclic graph)라고 부른다.

#### 차수(Degree)
그래프에서 한 노드에 인접한 간선의 수를 차수(degree)라고 부른다. 무방향 그래프에서는 노드의 차수가 연결된 노드의 수와 같으며, 방향 그래프에서는 인접한 노드의 수와 나가는 노드의 수로 구분된다.


## 그래프의 종류
그래프의 종류는 그래프가 가지는 구조와 특징에 따라서 구분된다.

![title](https://velog.velcdn.com/images/kwontae1313/post/991fc54b-6cdb-4ba9-8fb2-f96cb4302026/image.png)   


#### 무방향 그래프(Undirected Graph)

간선에 방향이 없는 그래프이다
노드와 간선으로 이루어져 있으며, 노드 사이의 관계는 양방향이다.

#### 방향 그래프(Directed Graph)

간선에 방향이 있는 그래프이다.
노드와 간선으로 이루어져 있으며, 노드 사이의 관계는 일방향이다.


#### 가중치 그래프(Weighted Graph)

간선에 가중치(weight)가 있는 그래프이다.
가중치는 간선의 비용, 거리, 시간 등을 나타낸다.

#### 이분 그래프(Bipartite Graph)

무방향 그래프에서, 노드를 두 그룹으로 나누었을 때, 같은 그룹 내의 노드는 서로 인접하지 않고, 다른 그룹의 노드와만 인접하는 그래프이다.

#### 비순환 그래프(Acyclic Graph)

사이클이 없는 그래프이다.
방향 그래프에서, 유향 비순환 그래프(Directed Acyclic Graph, DAG)라고도 한다.

![title](https://velog.velcdn.com/images/kwontae1313/post/3d6a6faf-f81b-4b45-90a5-b8a0705c62cf/image.png)   


#### 완전 그래프(Complete Graph)

모든 노드가 서로 연결된 그래프이다.
노드 수가 n일 때, 간선 수는 n(n-1)/2 입니다.
완전 그래프는 항상 연결그래프를 포함한다.

#### 부분 그래프(Subgraph)

주어진 그래프의 일부 노드와 간선으로 이루어진 그래프이다.

#### 연결 그래프(Connected Graph)

무방향 그래프에서, 모든 노드 사이에 경로가 존재하는 그래프이다.

#### 비연결 그래프(Disconnected Graph)

무방향 그래프에서, 연결 그래프가 아닌 그래프이다.

#### 강결합 그래프(Strongly Connected Graph)

방향 그래프에서, 모든 노드 사이에 양방향 경로가 존재하는 그래프이다.

## 그래프의 장단점

#### 장점
- 복잡한 관계를 직관적으로 표현할 수 있다.
- 네트워크 구조를 표현할 수 있어서 소셜 네트워크, 전력망, 노선도 등의 문제를 다룰 수 있다.
- 다양한 최적화 문제를 풀 수 있다.
  - 예를 들어, 최단 경로 문제나 최소 신장 트리 문제 등 다양한 그래프 알고리즘을 사용하여 최적화 문제를 풀 수 있다.

#### 단점
- 데이터의 규모가 커질수록 계산 비용이 증가한다. 대형 그래프에서는 탐색 비용과 알고리즘의 수행 시간 등이 중요한 문제가 될 수 있다.
- 그래프의 구성이 복잡하면 이를 이해하기 어려울 수 있다.
- 방향성 그래프에서는 경로의 유무가 중요하므로, 경로가 존재하지 않는 경우에는 이를 고려하여 알고리즘을 설계해야 한다.

#### 단점의 보완

- 분할 정복, 동적 계획법 등의 최적화 알고리즘을 사용하여, 계산 비용을 줄일 수 있다.
- 복잡해진 그래프를 시각화하는 방법을 고민하여, 데이터의 시각적 이해를 돕는 방법이 있다.
- 그래프를 단순화하여, 경로가 존재하지 않는 경우에도 유용한 결과를 도출할 수 있도록 만든다.
  - 예를 들면, 가중치를 조절하여 일정 이하의 가중치를 가진 간선들은 무시하는 방법을 생각할 수 있다.


# 그래프의 구현

## 인접 행렬 (Adjacency Materix)

컴퓨터에서 그래프를 구현하는 방법에는 배열(Array)을 사용하는 방법과 연결리스트(Linked List)를 사용하는 방법이 있다.


![인접 행렬을 이용한 그래프 구현](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FAX0fJ%2FbtqSsQxDVL3%2FUMyk36B9WbAqVOzNkLpO8k%2Fimg.png)   

그래프의 정점을 2차원 배열로 만든 것이다.

 
정점의 개수가 n이라면 n*n 형태의 2차원 배열이 인접 행렬로 사용된다.
인접 행렬에서 행과 열은 정점을 의미하며, 각각의 원소들은 정점 간의 간선을 나타낸다.

무방향 그래프는 (a), (b)에서 볼 수 있듯이 인접 행렬이 대칭적 구조를 가진다.
(두 개의 정점에서 간선이 동시에 연결되어 있기 때문)

가중치 그래프의 경우 행렬에서 0과 1이 아니라 각 간선의 가중치 값이 저장된다.
(이 경우 가중치가 0인 것과 간선이 없는 것이 구별돼야 함)

#### 장점

- 2차원 배열에 모든 정점들의 간선 정보가 있기 때문에, 두 정점을 연결하는 간선을 조회할 때 O(1) 시간복잡도로 가능하다.
- 정점(i)의 차수를 구할 때는 다음과 같이 인접행렬(M)의 i번째 행의 값을 모두 더하면 되므로 O(n)의 시간복잡도를 가진다.
- 구현이 비교적 간단하다.


#### 단점

- 간선의 수와 무관하게 항상 n² 크기의 2차원 배열이 필요하므로 메모리 공간이 낭비된다.
- 그래프의 모든 간선의 수를 알아내려면 인접행렬 전체를 확인해야 하므로 O(n²)의 시간이 소요된다.


## 그래프 구현 - 인접 리스트 (Adjacency List)
![인접 리스트를 이용한 그래프 구현](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FFT7FQ%2FbtqSASBFP80%2FIj5cIGUZ3Dk7YyoxvaFiZK%2Fimg.png)   


그래프의 각 정점에 인접한 정점들을 연결리스트(Linked List)로 표현하는 방법이다.

즉 정점의 개수만큼 인접리스트가 존재하며, 각각의 인접리스트에는 인접한 정점 정보가 저장되는 것이다.

그래프는 각 인접리스트에 대한 헤드포인터를 배열로 갖는다.

무방향 그래프의 경우 간선이 추가되면 각각의 정점의 인접리스트에 반대편 정점의 노드를 추가해야 한다.

#### 장점

- 존재하는 간선만 관리하면 되므로 메모리 사용 측면에서 보다 효율적이다.
- 그래프의 모든 간선의 수를 알아내려면 각 정점의 헤더 노드부터 모든 인접리스트를 탐색해야 하므로 O(n+e)의 시간이 소요된다.
 

#### 단점

- 두 정점을 연결하는 간선을 조회하거나 정점의 차수를 알기 위해서는 정점의 인접 리스트를 탐색해야 하므로 정점의 차수만큼의 시간이 필요하다. O(degree(v))
- 구현이 비교적 어렵다.



## 그래프의 탐색


# BFS(너비 우선 탐색)란?

![title](https://velog.velcdn.com/images/ashwon1218/post/083b90fe-3d1c-4bfa-883e-426a3e03d93e/image.png)   


루트 노드(혹은 임의의 다른 노드)에서부터 시작하여 인접한 노드를 먼저 탐색해 나가는 방법이다.

또한 BFS는 그래프에서 최단 경로를 찾는 정점 기반 알고리즘으로 유명하다.

 

특징은 다음과 같다.

- 시작 정점으로부터 가까운 정점을 먼저 방문하고 멀리 떨어져 있는 정점을 나중에 방문하는 순회 방법이다.
- 즉, 깊이(deep)탐색하기 전에 넓게(wide) 탐색하는 것이다.
- 사용하는 경우: 두 노드 사이의 최단 경로 혹은 임의의 경로를 찾고 싶을 때 이 방법을 선택한다.
- 예를 들어, 지구상의 존재하는 모든 인관관계를 표현한 후 철수와 영희 사이에 존재하는 경로를 찾는 경우
  - 깊이 우선 탐색(DFS)의 경우 - 모든 인간 관계를 다 살펴봐야 할 수도 있다.
  - 너비 우선 탐색(BFS)의 경우- 철수와 가까운 관계부터 탐색한다.
  - 너비 우선 탐색(BFS)이 깊이 우선 탐색(DFS)보다 더 복잡하다.
 

### BFS의 특징

- 직관적이지 않다.
  - BFS는 시작 노드를 기준으로 거리에 따라 단계별로 탐색하는 것이기 때문에 다소 오해가 발생할 수 있다.
- BFS는 재귀적으로 동작하지 않는다.(DFS와 달리)
- 이후 구현에서 다룰 것이지만 반드시 그래프를 탐색하면서 어떤 노드를 방문했었는 지의 여부를 검사해야한다. (구현에서 visited 변수)
  - 무한루프에 빠질 위험이 있기 때문
- BFS는 대기순서에 따라 반복적인 방문을 해야하기 때문에 큐(Queue)를 사용하여 구현한다.
  - 다시말해서 선입선출(FIFO)의 원칙으로 탐색
  - 다양한 방법이 있지만 queue의 형태로 구현하는 것이 바람직함
    - 먼저 들어온 데이터 들을 먼저 탐색하는 방식이기 때문.

#### BFS의 과정
![title](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FvsyEu%2FbtrVhTjTrWq%2FAcQAR7EkxP1wKKoikXMtbK%2Fimg.png)   

- 시작 노드 A를 방문한다.
- 시작 정점을 방문하여 방문 표시(visited, 초록색 표시)한 후 해당 노드를 enqueue한다.
- 큐에서 첫번째 정점을 제거하고 제거된 정점과 인접한 정점에 대하여 방문하지 않은 정점을 방문한다.
- 큐에서 꺼낸 노드를 방문한다.
- 이 노드와 인접하는 노드들을 모두 방문(enqueue)한다.
- 인접한 노드가 없으면 큐의 맨 앞(peek)에서 노드를 꺼낸다(dequeue).
- 큐가 소진될 때까지 위 과정을 반복한다.
 

큐에서 데이터가 빠짐(dequeue)과 동시에 해당 데이터는 초록색이 되고 이와 인접한 노드는 노란색이 되면서 방문(enqueue)을 한 상태가 되고 큐에서 순서대로 데이터를 빼면서(초록색으로 만들면서) 인접 노드들이 큐에 삽입되는(노란색이 되는, 큐에 진입) 과정을 반복하는 것이다. (모든 노드가 초록색이 될 때까지, 즉 큐가 빌 때까지 반복한다.)

방문순서 : A-B-C-D-E-F-G-H

### BFS 구현 (Swift)


```swift

func BFS(graph: [String: [String]], start: String) -> [String] {
    var visitedQueue: [String] = []
    var needVisitQueue: [String] = [start]
    
    while !needVisitQueue.isEmpty {
        let node: String = needVisitQueue.removeFirst()
        if visitedQueue.contains(node) { continue }
        
        visitedQueue.append(node)
        needVisitQueue += graph[node] ?? []
    }
    
    return visitedQueue
}

```


# DFS(너비 우선 탐색)란?

![title](https://velog.velcdn.com/images/ashwon1218/post/36068cfd-84b4-4fd7-a243-f4757a6c30a1/image.png)   

루트 노드(혹은 다른 임의의 노드)에서 시작해서 다음 분기(branch)로 넘어가기 전에 해당 분기를 완벽하게 탐색하는 방법

- 미로를 탐색할 때 한 방향으로 갈 수 있을 때까지 계속 가다가 더 이상 갈 수 없게 되면 다시 가장 가까운 갈림길로 돌아와서 이곳으로부터 다른 방향으로 다시 탐색을 진행하는 방법과 유사하다.
- 즉, 넓게(wide) 탐색하기 전에 깊게(deep) 탐색하는 것이다.
- 사용하는 경우: 모든 노드를 방문 하고자 하는 경우에 이 방법을 선택한다.
- 깊이 우선 탐색(DFS)이 너비 우선 탐색(BFS)보다 좀 더 간단하다.
- 단순 검색 속도 자체는 너비 우선 탐색(BFS)에 비해서 느리다.

### 깊이 우선 탐색(DFS)의 특징
- 자기 자신을 호출하는 순환 알고리즘의 형태 를 가지고 있다.
- 전위 순회(Pre-Order Traversals)를 포함한 다른 형태의 트리 순회는 모두 DFS의 한 종류이다.
- 이 알고리즘을 구현할 때 가장 큰 차이점은, 그래프 탐색의 경우 어떤 노드를 방문했었는지 여부를 반드시 검사 해야 한다는 것이다.
  - 이를 검사하지 않을 경우 무한루프에 빠질 위험이 있다.

#### DFS의 과정
![title](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbAruSu%2FbtrU9eXyzJY%2FHkckVpEEbCnUxXB6WlcUtk%2Fimg.png)   

- 시작 노드 A를 방문한다. (하나의 정점에서 시작한다.)
  - 시작 정점을 스택에 push한다.
  - 스택에 맨 위에 있는 정점을 pop하고 방문 표시(visited, 초록색 표시)를 한다.
 

- 큐에서 꺼낸 노드와 인접한 노드들을 순차대로 방문한다.(간선을 따라 다음 정점으로 방문한다.)
- pop된 정점에서 방문하지 않은 인접한 모든 정점들을 스택에 push한다.
- 방문하지 않은 노드들 중에서 인접한 노드가 없으면 큐의 맨 앞(peek)에서 노드를 pop한다.
 

- 스택이 소진될 때까지 반복한다.
DFS는 인접한 노드들을 바로 다 탐색하는 것이 아니라 인접한 노드 중에서 더 깊이 들어갈 수 있는 노드가 있으면 그 분기(branch)를 먼저 다 탐색해야 그 전의 노드들을 탐색할 수 있습니다.

후입선출: 나중에 들어온 것 중에서 깊이를 탐색하여 이를 높은 우선순위로 탐색 진행
 

스택에서 데이터가 빠짐(pop)과 동시에 해당 데이터는 초록색이 되고 이와 인접한 노드는 노란색이 되면서 방문(push)을 한 상태(스택에 진입한 상태)가 되고 큐에서 순서대로 데이터를 빼면서(초록색으로 만들면서,or visited에 들어가면서) 인접 노드들이 큐에 삽입되는(노란색이 되는, 스택에 진입) 과정을 반복하는 것이다. (모든 노드가 초록색이 될 때까지, 스택이 빌 때까지 반복한다.)

방문순서 : A-B-E-D-H-G-C-F

### DFS 구현 (Swift)

```swift

func DFS(graph: [String: [String]], start: String) -> [String] {
    var visitedQueue: [String] = []
    var needVisitStack: [String] = [start]
    
    while !needVisitStack.isEmpty {
        let node: String = needVisitStack.removeLast()
        if visitedQueue.contains(node) { continue }
        
        visitedQueue.append(node)
       needVisitStack += graph[node] ?? []
    }
    
    return visitedQueue
}

```
